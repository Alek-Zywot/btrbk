#!/usr/bin/perl

=head1 NAME

btrbk - backup btrfs volumes at file-system level

=head1 SYNOPSIS

    btrbk --help

=head1 DESCRIPTION

Backup tool for btrfs (sub-)volumes, taking advantage of btrfs
specific send-receive mechanism, allowing incremental backups at
file-system level.

The full btrbk documentation is available at L<http://www.digint.ch/btrbk>.

=head1 AUTHOR

Axel Burri <axel@tty0.ch>

=head1 COPYRIGHT AND LICENSE

Copyright (c) 2014 Axel Burri. All rights reserved.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

=cut

use strict;
use warnings FATAL => qw( all );

use POSIX qw(strftime);
use File::Path qw(make_path);
use Getopt::Std;
use Data::Dumper;

our $VERSION = "0.01";
our $PROJECT_HOME = '<http://www.digint.ch/btrbk>';

my $version_info = "btrbk command line client, version $VERSION";
my $time_format = "%Y%m%d_%H%M%S";

my $default_config = "/etc/btrbk.conf";
my $src_snapshot_dir = "_btrbk_snap";

my %vol_info;
my $dryrun;
my $loglevel = 1;

sub VERSION_MESSAGE
{
  print STDERR $version_info . "\n\n";
}

sub HELP_MESSAGE
{
  print STDERR "usage: $0 [options] <command>\n";
  print STDERR "\n";
  print STDERR "options:\n";
  print STDERR "   --help      display this help message\n";
  print STDERR "   --version   display version information\n";
  print STDERR "   -c          config file\n";
  print STDERR "   -v          be verbose (set loglevel=info)\n";
  print STDERR "   -l LEVEL    set loglevel (1=warn, 2=info, 3=debug, 4=trace)\n";
  print STDERR "\n";
  print STDERR "commands:\n";
  print STDERR "   info        shows information\n";
  print STDERR "   execute     perform all backups\n";
  print STDERR "   dryrun      don't run btrfs commands, just show what would be executed\n";
  print STDERR "\n";
  print STDERR "For additional information, see $PROJECT_HOME\n";
}

sub TRACE { my $t = shift; print STDOUT "... $t\n" if($loglevel >= 4);  }
sub DEBUG { my $t = shift; print STDOUT "$t\n" if($loglevel >= 3);  }
sub INFO  { my $t = shift; print STDOUT "$t\n" if($loglevel >= 2);  }
sub WARN  { my $t = shift; print STDOUT "WARNING: $t\n" if($loglevel >= 1);  }
sub ERROR { my $t = shift; print STDOUT "ERROR: $t\n";  }

sub run_cmd($;$)
{
  my $cmd = shift;
  my $non_destructive = shift;
  my $ret = "";
  DEBUG "### $cmd" unless($non_destructive);
  if($non_destructive || (not $dryrun)) {
    TRACE "### $cmd";
    $ret = `$cmd`;
    chomp($ret);
    TRACE "command output:\n$ret";
    die("command execution failed: \"$cmd\"") if($?);
  }
  return $ret;
}


sub check_vol($$)
{
  my $root = shift;
  my $vol = shift;
  die("subvolume info not present: $root") unless(exists($vol_info{$root}));
  foreach (values %{$vol_info{$root}}) {
    return 1 if($_->{FS_PATH} eq "$root/$vol");
  }
  return 0;
}


sub check_src($$)
{
  my $root = shift;
  my $vol = shift;
  return 0 unless(check_vol($root, $vol));
  unless($dryrun)
  {
    my $dir = "${root}/${src_snapshot_dir}";
    unless(-d $dir) {
      INFO "Creating snapshot directory: $dir\n";
      make_path("${root}/${src_snapshot_dir}");
    }
  }
  return 1;
}


sub check_rootvol($)
{
  my $vol = shift;
  my $ret = run_cmd("/sbin/btrfs subvolume show $vol 2>/dev/null", 1);
  if($ret eq "$vol is btrfs root") {
    TRACE "rootvol check passed: $vol";
    return 1;
  }
  TRACE "rootvol check failed: $vol";
  return 0;
}


sub parse_config($)
{
  my $file = shift;
  my @jobs;
  unless(-r "$file") {
    WARN "Configuration file not found: $file";
    return undef;
  }

  TRACE "parsing config file: $file";
  open(FILE, '<', $file) or die $!;
  while (<FILE>) {
    chomp;
    next if /^\s*#/; # ignore comments
    next if /^\s*$/; # ignore empty lines
    TRACE "parse_config: parsing line: $_";
    if(/^\s*(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s*$/)
    {
      my %job = ( type  => "subvol_backup",
                  sroot => $1,
                  svol  => $2,
                  droot => $3,
                  dvol  => $4,
                  options => [ split(/,/, $5) ],
                 );
      $job{sroot} =~ s/\/+$//;   # remove trailing slash
      $job{sroot} =~ s/^\/+/\//; # sanitize leading slash
      $job{svol} =~ s/\/+$//;    # remove trailing slash
      $job{svol} =~ s/^\/+//;    # remove leading slash
      die("svol contains slashes: $job{svol}") if($job{svol} =~ /\//);

      $job{droot} =~ s/\/+$//;   # remove trailing slash
      $job{droot} =~ s/^\/+/\//; # sanitize leading slash
      $job{dvol} =~ s/\/+$//;    # remove trailing slash
      $job{dvol} =~ s/^\/+//;    # remove leading slash
      die("dvol contains slashes: $job{svol}") if($job{svol} =~ /\//);

      $job{mountpoint} = $job{sroot}; # TODO: honor this, automount

      TRACE "parse_config: adding job \"$job{type}\": $job{sroot}/$job{svol} -> $job{droot}/$job{dvol}";
      push @jobs, \%job;
    }
    else
    {
      WARN "Ambiguous configuration: $file line $.";
      return undef; # be very strict here
    }
  }
  close FILE;
  TRACE "jobs: " . Dumper(\@jobs);
  return \@jobs;
}


sub btr_tree($)
{
  my $vol = shift;
  unless(check_rootvol($vol)) {
    ERROR "\"$vol\" is not btrfs root!";
    return undef;
  }
  my $ret = run_cmd("/sbin/btrfs subvolume list -u -q -a $vol", 1);
  my %tree;
  foreach (split(/\n/, $ret))
  {
    # ID <ID> top level <ID> path <path> where path is the relative path
    # of the subvolume to the top level subvolume. The subvolume?s ID may
    # be used by the subvolume set-default command, or at mount time via
    # the subvolid= option. If -p is given, then parent <ID> is added to
    # the output between ID and top level. The parent?s ID may be used at
    # mount time via the subvolrootid= option.
    die("Failed to parse line: \"$_\"") unless(/^ID ([0-9]+) gen ([0-9]+) top level ([0-9]+) parent_uuid ([0-9a-z-]+) uuid ([0-9a-z-]+) path (.+)$/);
    my %node = ( ID          => $1,
                 gen         => $2,
                 top_level   => $3,
                 parent_uuid => $4,
                 uuid        => $5,
                 path        => $6
                );
    $node{parent_uuid} = undef if($node{parent_uuid} eq '-');
    $tree{$node{ID}} = \%node;
    TRACE "btr_tree: processing subvolid=$node{ID}";

    # set FS_PATH
    #
    # NOTE: these substitutions are only valid if $root is a
    # absolute path to a btrfs root volume (mounted with
    # subvolumeid=0)
    TRACE "btr_tree: original path: $node{path}";
    $node{FS_PATH} =  $node{path};
    if($node{FS_PATH} =~ s/^<FS_TREE>\///) {
      TRACE "btr_tree: removed <FS_TREE> portion subvolume path: $node{FS_PATH}";
    }

    $node{SUBVOL_PATH} = $node{FS_PATH};
    TRACE "btr_tree: set SUBVOL_PATH: $node{FS_PATH}";

    $node{FS_PATH} =  $vol . "/" . $node{FS_PATH};
    TRACE "btr_tree: set FS_PATH: $node{FS_PATH}";

    if($node{top_level} != 5)
    {
      # man btrfs-subvolume:
      #   Also every btrfs filesystem has a default subvolume as its initially
      #   top-level subvolume, whose subvolume id is 5(FS_TREE).

      # set child/parent node
      die unless exists($tree{$node{top_level}});
#      $tree{$node{top_level}}->{SUBVOL}->{$node{ID}} = \%node;
      $tree{$node{ID}}->{PARENT_NODE} = $tree{$node{top_level}};
    }
  }
  return \%tree;
}


sub btrfs_snapshot($$)
{
  my $src = shift;
  my $dst = shift;
  DEBUG "[btrfs] snapshot (ro):";
  DEBUG "[btrfs]   source: $src";
  DEBUG "[btrfs]   dest  : $dst";
  INFO ">>> $dst";
  run_cmd("/sbin/btrfs subvolume snapshot -r $src $dst");
}


sub btrfs_send_receive($$;$$)
{
  my $src = shift;
  my $dst = shift;
  my $parent = shift // "";
  my $changelog = shift // "";
  my $now = localtime;

  my $src_name = $src;
  $src_name =~ s/^.*\///;
  INFO ">>> $dst/$src_name";
#  INFO (($parent ? ">>>" : "+++") . " $dst/$src_name");
#  INFO (($parent ? ">>> receive(incremental):" : ">>> receive(complete):") . " $dst/$src_name");
  # INFO ">>> $dst/$src_name  ". ($parent ? "(incremental)" : "(INIT)");

  my @info;
  push @info, "[btrfs] send/receive" . ($parent ? " (incremental)" : " (complete)") . ":";
  push @info, "[btrfs]   source: $src";
  push @info, "[btrfs]   parent: $parent" if($parent);
  push @info, "[btrfs]   dest  : $dst";
  push @info, "[btrfs]   log   : $changelog" if($changelog);
  DEBUG $_ foreach(@info);

  my $parent_option = $parent ? "-p $parent" : "";
  my $receive_option = "";
  $receive_option = "-v" if($changelog || ($loglevel >= 2));
  $receive_option = "-v -v" if($parent && $changelog);
  my $cmd = "/sbin/btrfs send $parent_option $src | /sbin/btrfs receive $receive_option $dst/ 2>&1";
  my $ret = run_cmd($cmd);
  # run_cmd("/bin/sync");
  if($changelog && (not $dryrun))
  {
    INFO "Writing btrfs-diff changelog: $changelog";
    if(open(LOGFILE, '>>', $changelog)) {
      print LOGFILE "<<< START btrfs_send_receive: $now >>>\n";
      print LOGFILE "$_\n" foreach(@info);
      print LOGFILE "[btrfs]   cmd   : $cmd\n";
      print LOGFILE "[btrfs]   cmd output:\n" . $ret;
      print LOGFILE "\n<<< END btrfs_send_receive: $now >>>\n";
      close(LOGFILE);
    }
    else {
      WARN "Failed to open changelog file: $!";
    }
  }
}

sub get_latest_common($$$$)
{
  my $sroot = shift;
  my $svol = shift;
  my $droot = shift;
  my $dvol = shift;

  die("source subvolume info not present: $sroot") unless(exists($vol_info{$sroot}));
  die("target subvolume info not present: $droot") unless(exists($vol_info{$droot}));
  my $latest;
  my @svol_list;
  foreach (values %{$vol_info{$sroot}}) {
    my $v = $_->{SUBVOL_PATH};
    TRACE "get_latest_common(): checking source volume: $v";
    next unless($v =~ s/^$src_snapshot_dir\/$svol\./$svol\./);
    TRACE "get_latest_common(): found source snapshot: $v";
    push @svol_list, $v;
  }

  foreach (values %{$vol_info{$droot}}) {
    my $v = $_->{SUBVOL_PATH};
    TRACE "get_latest_common(): checking dest volume: $v";
    next unless($v =~ s/^$dvol\///);
    if(grep {$_ eq $v} @svol_list) {
      TRACE "get_latest_common(): found matching dest snapshot: $v";
      $latest = $v if((not defined($latest)) || ($latest lt $v));
    }
    else {
      TRACE "get_latest_common(): found non-matching dest snapshot: $v";
    }
  }
  DEBUG("No common snapshots for \"${svol}.*\" found in src=$sroot/$src_snapshot_dir/  dst=$droot/$dvol/") unless($latest);
  TRACE "get_latest_common(): latest common snapshot: " . ($latest ? "latest" : "<no_match>");
  return $latest;
}


MAIN:
{
  $ENV{PATH} = '';
  $Getopt::Std::STANDARD_HELP_VERSION = 1;
  $Data::Dumper::Sortkeys = 1;

  my %opts;
  getopts('c:vl:p', \%opts);
  my $command = shift @ARGV;

  # assign command line options
  $loglevel = $opts{l} || 0;
  if   (lc($loglevel) eq "warn")  { $loglevel = 1; }
  elsif(lc($loglevel) eq "info")  { $loglevel = 2; }
  elsif(lc($loglevel) eq "debug") { $loglevel = 3; }
  elsif(lc($loglevel) eq "trace") { $loglevel = 4; }
  elsif($loglevel =~ /^[0-9]+$/) { ; }
  else {
    $loglevel = $opts{v} ? 2 : 0;
  }
  my $config = $opts{c} || $default_config;

  # check command line options
  if($opts{h} || (not $command)) {
    VERSION_MESSAGE();
    HELP_MESSAGE(0);
    exit 0;
  }

  my $action_execute;
  my $action_info;
  if(($command eq "execute") || ($command eq "dryrun")) {
    $action_execute = 1;
    $dryrun = 1 if($command eq "dryrun");
  }
  elsif($command eq "info") {
    $action_info = 1;
  }
  else {
    ERROR "Unrecognized command: $command";
    HELP_MESSAGE(0);
    exit 1;
  }

  #
  # check jobs, fill vol_info hash
  #
  my $jobs = parse_config($config);
  unless($jobs) {
    ERROR "Failed to parse configuration file";
    exit 1;
  }
  foreach my $job (@$jobs)
  {
    my $sroot = $job->{sroot} || die;
    my $droot = $job->{droot} || die;
    $vol_info{$sroot} //= btr_tree($sroot);
    $vol_info{$droot} //= btr_tree($droot);
    unless($vol_info{$sroot} && $vol_info{$droot}) {
      ERROR "Failed to read btrfs subvolume information, aborting job";
      $job->{ABORTED} = 1;
      next;
    }
  }
  TRACE(Data::Dumper->Dump([\%vol_info], ["vol_info"]));

  if($action_info)
  {
    #
    # print snapshot tree
    #
    my %info;
    foreach my $job (@$jobs)
    {
      $info{$job->{sroot}}->{$job->{svol}} = $job;
    }
    foreach my $root (keys %info)
    {
      print "$root\n";
      foreach my $job (values %{$info{$root}})
      {
        my $sroot = $job->{sroot} || die;
        my $svol  = $job->{svol}  || die;
        next unless $vol_info{$job->{sroot}};
        print "|-- $svol\n";
        my $sroot_uuid;
        foreach (values $vol_info{$sroot}) {
          if($_->{FS_PATH} eq "$sroot/$svol") {
            die if $sroot_uuid;
            $sroot_uuid = $_->{uuid};
          }
        }
        die unless $sroot_uuid;
        foreach (values $vol_info{$sroot}) {
          next unless($_->{parent_uuid} && ($_->{parent_uuid} eq $sroot_uuid));
          # next unless($_->{SUBVOL_PATH} =~ /^$src_snapshot_dir\//);  # don't print non-btrbk snapshots
          print "|   ^-- $_->{SUBVOL_PATH}\n";
          my $snapshot = $_->{FS_PATH};
          $snapshot =~ s/^.*\///;
          foreach (@$jobs) {
            next unless $vol_info{$_->{droot}};
            next unless(($_->{sroot} eq $sroot) && ($_->{svol} eq $svol));
            my $match = "$_->{droot}/$_->{dvol}/$snapshot";
            foreach (values $vol_info{$_->{droot}}) {
              print "|   |   # $_->{FS_PATH}\n" if($_->{FS_PATH} eq $match);
            }
          }
        }
      }
      print "\n";
    }
  }

  if($action_execute)
  {
    my $postfix = '.' . strftime($time_format, localtime);
    #
    # create snapshots
    #
    my %snapshots;
    foreach my $job (@$jobs)
    {
      my $sroot    = $job->{sroot}      || die;
      my $svol     = $job->{svol}       || die;
      my $droot    = $job->{droot}      || die;
      my $dvol     = $job->{dvol}       || die;
      my $type     = $job->{type}       || die;
      my $ssnap = "$src_snapshot_dir/$svol$postfix";

      # perform checks
      if(check_vol($sroot, $ssnap)) {
        # TODO: consider using numbered snapshot name instead of timestamp
        ERROR "Snapshot already exists, aborting job: $sroot/$ssnap";
        $job->{ABORTED} = 1;
        next;
      }
      if(check_vol($droot, "$dvol/$svol$postfix")) {
        WARN "Snapshot already exists at destination, aborting job: $droot/$dvol/$svol$postfix";
        $job->{ABORTED} = 1;
        next;
      }
      unless(check_src($sroot, $svol) && check_vol($sroot, $svol)) {
        WARN "Source subvolume not found, aborting job: $sroot/$svol";
        $job->{ABORTED} = 1;
        next;
      }

      # make snapshot of svol, if not already created by another job
      unless($snapshots{"$sroot/$svol"})
      {
        DEBUG "***";
        DEBUG "*** snapshot";
        DEBUG "***   source: $sroot/$svol";
        DEBUG "***   dest  : $sroot/$ssnap";
        DEBUG "***";
        INFO "Creating subvolume snapshot for: $sroot/$svol";

        btrfs_snapshot("$sroot/$svol", "$sroot/$ssnap");
        $snapshots{"$sroot/$svol"} = "$sroot/$ssnap";
      }
      $job->{snapshot} = $snapshots{"$sroot/$svol"};
    }

    #
    # create backups
    #
    foreach my $job (@$jobs)
    {
      next if($job->{ABORTED});

      my $sroot    = $job->{sroot}      || die;
      my $svol     = $job->{svol}       || die;
      my $droot    = $job->{droot}      || die;
      my $dvol     = $job->{dvol}       || die;
      my $type     = $job->{type}       || die;
      my $snapshot = $job->{snapshot}   || die;
      my @job_opts = @{$job->{options}};

      DEBUG "***";
      DEBUG "*** $type\[" . join(',', @job_opts) . "]";
      DEBUG "***   source: $sroot/$svol";
      DEBUG "***   dest  : $droot/$dvol";
      DEBUG "***";
      INFO "Creating subvolume backup for: $sroot/$svol";

      my $changelog = "";
      if(grep(/^log/, @job_opts))
      {
        if(my @res = grep(/^log=\S+$/, @job_opts)) {
          die if(scalar(@res) != 1);
          $changelog = $res[0];
          $changelog =~ s/^log=//;
        }
        else {
          # log defaults to sidecar of destination snapshot
          $changelog = "$droot/$dvol/$svol$postfix.btrbk.log";
        }
      }
      if(grep(/incremental/, @job_opts))
      {
        INFO "Using previously created snapshot: $snapshot";
        # INFO "Attempting incremantal backup (option=incremental)";
        my $latest_common = get_latest_common($sroot, $svol, $droot, $dvol);
        if($latest_common)
        {
          my $parent_snap = "$src_snapshot_dir/$latest_common";
          INFO "Using common parent snapshot: $sroot/$parent_snap";
          die("snapshot parent source does not exists: $sroot/$parent_snap") unless check_vol($sroot, $parent_snap);
          btrfs_send_receive($snapshot, "$droot/$dvol", "$sroot/$parent_snap", $changelog);
        }
        elsif(grep(/init/, @job_opts)) {
          if(check_vol($droot, $dvol)) {
            INFO "No common parent snapshots found, creating initial backup (option=init)";
            btrfs_send_receive($snapshot, "$droot/$dvol", undef, $changelog);
          }
          else {
            WARN "Backup to $droot failed: target subvolume not found: $droot/$dvol";
          }
        }
        else {
          WARN "Backup to $droot failed: no common parent subvolume found, and job option \"create\" is not set";
        }
      }
      elsif(grep(/create/, @job_opts))
      {
        INFO "Creating new snapshot copy (option=create))";
        btrfs_send_receive($snapshot, "${droot}/${dvol}", undef, $changelog);
      }
    }
  }
}
1;
