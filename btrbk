#!/usr/bin/perl -T

=head1 NAME

btrbk - backup tool for btrfs volumes

=head1 SYNOPSIS

    btrbk --help

=head1 DESCRIPTION

Backup tool for btrfs subvolumes, taking advantage of btrfs specific
send-receive mechanism, allowing incremental backups at file-system
level.

The full btrbk documentation is available at L<http://www.digint.ch/btrbk/>.

=head1 AUTHOR

Axel Burri <axel@tty0.ch>

=head1 COPYRIGHT AND LICENSE

Copyright (c) 2014-2015 Axel Burri. All rights reserved.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

=cut

use strict;
use warnings FATAL => qw( all );

use Carp qw(confess);
use Date::Calc qw(Today Delta_Days Day_of_Week);
use Getopt::Std;
use Data::Dumper;

our $VERSION       = "0.17.0-dev";
our $AUTHOR        = 'Axel Burri <axel@tty0.ch>';
our $PROJECT_HOME  = '<http://www.digint.ch/btrbk/>';

my $version_info   = "btrbk command line client, version $VERSION";

my @config_src = ("/etc/btrbk.conf", "/etc/btrbk/btrbk.conf");

my %day_of_week_map = ( monday => 1, tuesday => 2, wednesday => 3, thursday => 4, friday => 5, saturday => 6, sunday => 7 );

my %config_options = (
  # NOTE: the parser always maps "no" to undef
  # NOTE: keys "volume", "subvolume" and "target" are hardcoded
  snapshot_dir              => { default => undef,    accept_file => { relative => 1 } },
  snapshot_name             => { default => undef,    accept_file => { name_only => 1 }, context => [ "subvolume" ] },
  receive_log               => { default => undef,    accept => [ "sidecar", "no" ], accept_file => { absolute => 1 }, deprecated => "removed" },
  incremental               => { default => "yes",    accept => [ "yes", "no", "strict" ] },
  snapshot_create_always    => { default => undef,    accept => [ "yes", "no" ] },
  resume_missing            => { default => "yes",    accept => [ "yes", "no" ] },
  preserve_day_of_week      => { default => "sunday", accept => [ (keys %day_of_week_map) ] },
  snapshot_preserve_daily   => { default => "all",    accept => [ "all" ], accept_numeric => 1  },
  snapshot_preserve_weekly  => { default => 0,        accept => [ "all" ], accept_numeric => 1  },
  snapshot_preserve_monthly => { default => "all",    accept => [ "all" ], accept_numeric => 1  },
  target_preserve_daily     => { default => "all",    accept => [ "all" ], accept_numeric => 1  },
  target_preserve_weekly    => { default => 0,        accept => [ "all" ], accept_numeric => 1  },
  target_preserve_monthly   => { default => "all",    accept => [ "all" ], accept_numeric => 1  },
  btrfs_commit_delete       => { default => undef,    accept => [ "after", "each", "no" ] },
  ssh_identity              => { default => undef,    accept_file => { absolute => 1 } },
  ssh_user                  => { default => "root",   accept_regexp => qr/^[a-z_][a-z0-9_-]*$/ },
  btrfs_progs_compat        => { default => undef,    accept => [ "yes", "no" ] },
 );

my @config_target_types = qw(send-receive);

my %vol_info;
my %uuid_info;
my %uuid_fs_map;

my $dryrun;
my $loglevel = 1;

my $ip_addr_match = qr/(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])/;
my $host_name_match = qr/(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9])\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\-]*[A-Za-z0-9])/;
my $file_match = qr/[0-9a-zA-Z_@\-\.\/]+/;  # note: ubuntu uses '@' in the subvolume layout: <https://help.ubuntu.com/community/btrfs>
my $ssh_prefix_match = qr/ssh:\/\/($ip_addr_match|$host_name_match)/;


$SIG{__DIE__} = sub {
  print STDERR "\nERROR: process died unexpectedly (btrbk v$VERSION)";
  print STDERR "\nPlease contact the author: $AUTHOR\n\n";
  print STDERR "Stack Trace:\n----------------------------------------\n";
  Carp::confess @_;
};

sub VERSION_MESSAGE
{
  print STDERR $version_info . "\n\n";
}

sub HELP_MESSAGE
{
  print STDERR "usage: btrbk [options] <command>\n";
  print STDERR "\n";
  print STDERR "options:\n";
  print STDERR "   --help      display this help message\n";
  print STDERR "   --version   display version information\n";
  print STDERR "   -c FILE     specify configuration file\n";
  print STDERR "   -p          preserve all backups (do not delete any old targets)\n";
  print STDERR "   -v          be verbose (set loglevel=info)\n";
  print STDERR "   -q          be quiet (do not print summary at end of \"run\" command)\n";
  print STDERR "   -l LEVEL    set loglevel (warn, info, debug, trace)\n";
  print STDERR "\n";
  print STDERR "commands:\n";
  print STDERR "   run         perform backup operations as defined in the configuration\n";
  print STDERR "   dryrun      don't run btrfs commands, just show what would be executed\n";
  print STDERR "   info        print useful filesystem information\n";
  print STDERR "   tree        shows backup tree\n";
  print STDERR "   origin <subvol>   print origin information for subvolume\n";
  print STDERR "   diff <from> <to>  shows new files since subvolume <from> for subvolume <to>\n";
  print STDERR "\n";
  print STDERR "For additional information, see $PROJECT_HOME\n";
}

sub TRACE { my $t = shift; print STDOUT "... $t\n" if($loglevel >= 4);  }
sub DEBUG { my $t = shift; print STDOUT "$t\n" if($loglevel >= 3);  }
sub INFO  { my $t = shift; print STDOUT "$t\n" if($loglevel >= 2);  }
sub WARN  { my $t = shift; print STDOUT "WARNING: $t\n" if($loglevel >= 1);  }
sub ERROR { my $t = shift; print STDOUT "ERROR: $t\n";  }


sub run_cmd($;$)
{
  my $cmd = shift || die;
  my $non_destructive = shift;
  my $ret = "";
  $cmd =~ s/^\s+//;
  $cmd =~ s/\s+$//;
  if($non_destructive || (not $dryrun)) {
    DEBUG "### $cmd";
    $ret = `$cmd`;
    chomp($ret);
    TRACE "Command output:\n$ret";
    if($?) {
      my $exitcode= $? >> 8;
      my $signal = $? & 127;
      WARN "Command execution failed (exitcode=$exitcode" . ($signal ? ", signal=$signal" : "") . "): \"$cmd\"";
      return undef;
    }
    else {
      DEBUG "Command execution successful";
    }
  }
  else {
    DEBUG "### (dryrun) $cmd";
  }
  return $ret;
}


sub subvol($$)
{
  my $root = shift || die;
  my $vol = shift // die;
  if($root->{SUBVOL_INFO} && $root->{SUBVOL_INFO}->{$vol}) {
    return $root->{SUBVOL_INFO}->{$vol}->{node};
  }
  return undef;
}


sub vinfo($;$)
{
  my $url = shift // die;
  my $config = shift;
  if($vol_info{$url}) {
    TRACE "vinfo cache hit: $url";
    return $vol_info{$url};
  }

  die unless($config);

  my $name = $url;
  $name =~ s/^.*\///;
  my %info = (
    URL  => $url,
    NAME => $name,
   );

  if($url =~ /^ssh:\/\/(\S+?)(\/\S+)$/) {
    my ($host, $path) = ($1, $2);
    my $ssh_user      = config_key($config, "ssh_user");
    my $ssh_identity  = config_key($config, "ssh_identity");
    my $ssh_options   = "";
    if($ssh_identity) {
      $ssh_options .= "-i $ssh_identity ";
    }
    else {
      WARN "No SSH identity provided (option ssh_identity is not set) for: $url";
    }
    %info = (
      %info,
      HOST         => $host,
      PATH         => $path,
      PRINT        => "$host:$path",
      RSH_TYPE     => "ssh",
      SSH_USER     => $ssh_user,
      SSH_IDENTITY => $ssh_identity,
      RSH          => "/usr/bin/ssh $ssh_options" . $ssh_user . '@' . $host,
     );
  }
  elsif(($url =~ /^\//) && ($url =~ /^$file_match$/)) {
    %info = (
      %info,
      PATH   => $url,
      PRINT  => $url,
     );
  }
  else {
    die "Ambiguous vinfo url: $url";
  }

  my $btrfs_progs_compat = config_key($config, "btrfs_progs_compat");
  $info{BTRFS_PROGS_COMPAT} = $btrfs_progs_compat if($btrfs_progs_compat);

  DEBUG "vinfo created for: $url";
  TRACE(Data::Dumper->Dump([\%info], ["vinfo{$url}"]));
  $vol_info{$url} = \%info;

  return \%info;
}


sub vinfo_read_detail($)
{
  my $vol = shift || die;

  if($vol->{id}) {
    TRACE "vinfo detail cache hit: $vol->{URL}";
    return $vol;
  }

  my $detail = btr_subvolume_detail($vol);
  unless($detail) {
    WARN "Failed to fetch subvolume detail for: $vol->{PRINT}";
    return undef;
  }

  # add detail data to vinfo hash
  foreach(keys %$detail) {
    if((defined $vol->{$_}) && ($vol->{$_} ne $detail->{$_})) {
      WARN "Subvolume detail key \"$_\" is already present, with a different value: old=\"$vol->{$_}\", new=\"$detail->{$_}\"";
      WARN "Using new value for \"$_\": $detail->{$_}";
    }
    $vol->{$_} = $detail->{$_};
  }

  if($vol->{RSH_TYPE} && ($vol->{RSH_TYPE} eq "ssh")) {
    $vol->{REAL_URL} = "ssh://$vol->{HOST}$vol->{REAL_PATH}";
  } else {
    $vol->{REAL_URL} = $vol->{REAL_PATH};
  }


  DEBUG "vinfo updated for: $vol->{URL}";
  TRACE(Data::Dumper->Dump([$vol], ["vinfo{$vol->{URL}}"]));

  return $vol;
}


sub get_rsh($$)
{
  my $url = shift // die;
  my $config = shift;
  if($config && ($url =~ /^ssh:\/\/(\S+?)(\/\S+)$/)) {
    my ($ssh_host, $path) = ($1, $2);
    my $ssh_user     = config_key($config, "ssh_user");
    my $ssh_identity = config_key($config, "ssh_identity");
    my $ssh_options = "";
    if($ssh_identity) {
      $ssh_options .= " -i $ssh_identity";
    }
    else {
      WARN "No SSH identity provided (option ssh_identity is not set) for: $url";
    }
    my $rsh = "/usr/bin/ssh $ssh_options " . $ssh_user . '@' . $ssh_host;
    return ($rsh, $path);
  }
  return ("", $url);
}


sub config_key($$)
{
  my $node = shift || die;
  my $key = shift || die;
  TRACE "config_key: context=$node->{CONTEXT}, key=$key";
  while(not exists($node->{$key})) {
    return undef unless($node->{PARENT});
    $node = $node->{PARENT};
  }
  TRACE "config_key: found value=" . ($node->{$key} // "<undef>");
  return $node->{$key};
}


sub check_file($$;$$)
{
  my $file = shift // die;
  my $accept = shift || die;
  my $key = shift;  # only for error text
  my $config_file = shift;  # only for error text

  if($accept->{ssh} && ($file =~ /^ssh:\/\//)) {
    unless($file =~ /^$ssh_prefix_match\/$file_match$/) {
      ERROR "Ambiguous ssh url for option \"$key\" in \"$config_file\" line $.: $file";
      return undef;
    }
  }
  elsif($file =~ /^$file_match$/) {
    if($accept->{absolute}) {
      unless($file =~ /^\//) {
        ERROR "Only absolute files allowed for option \"$key\" in \"$config_file\" line $.: $file";
        return undef;
      }
    }
    elsif($accept->{relative}) {
      if($file =~ /^\//) {
        ERROR "Only relative files allowed for option \"$key\" in \"$config_file\" line $.: $file";
        return undef;
      }
    }
    elsif($accept->{name_only}) {
      if($file =~ /\//) {
        ERROR "Option \"$key\" is not a valid file name in \"$config_file\" line $.: $file";
        return undef;
      }
    }
    else {
      die("accept_type must contain either 'relative' or 'absolute'");
    }
  }
  else {
    ERROR "Ambiguous file for option \"$key\" in \"$config_file\" line $.: $file";
    return undef;
  }
  return 1;
}


sub parse_config(@)
{
  my @config_files = @_;
  my $file = undef;
  foreach(@config_files) {
    TRACE "config: checking for file: $_";
    if(-r "$_") {
      $file = $_;
      last;
    }
  }
  unless($file) {
    ERROR "Configuration file not found: " . join(', ', @config_files);
    return undef;
  }

  my $root = { CONTEXT => "root", SRC_FILE => $file };
  my $cur = $root;
  # set defaults
  foreach (keys %config_options) {
    $root->{$_} = $config_options{$_}->{default};
  }

  DEBUG "config: parsing file: $file";
  open(FILE, '<', $file) or die $!;
  while (<FILE>) {
    chomp;
    next if /^\s*#/; # ignore comments
    next if /^\s*$/; # ignore empty lines
    TRACE "config: parsing line $. with context=$cur->{CONTEXT}: \"$_\"";
    if(/^(\s*)([a-zA-Z_]+)\s+(.*)$/)
    {
      my ($indent, $key, $value) = (length($1), lc($2), $3);
      $value =~ s/\s*$//;
      # NOTE: we do not perform checks on indentation!

      if($key eq "volume")
      {
        $cur = $root;
        DEBUG "config: context forced to: $cur->{CONTEXT}";

        # be very strict about file options, for security sake
        return undef unless(check_file($value, { absolute => 1, ssh => 1 }, $key, $file));
        $value =~ s/\/+$//;   # remove trailing slash
        $value =~ s/^\/+/\//; # sanitize leading slash
        DEBUG "config: adding volume \"$value\" to root context";
        my $volume = { CONTEXT => "volume",
                       PARENT => $cur,
                       url => $value,
                      };
        $cur->{VOLUME} //= [];
        push(@{$cur->{VOLUME}}, $volume);
        $cur = $volume;
      }
      elsif($key eq "subvolume")
      {
        while($cur->{CONTEXT} ne "volume") {
          if(($cur->{CONTEXT} eq "root") || (not $cur->{PARENT})) {
            ERROR "Subvolume keyword outside volume context, in \"$file\" line $.";
            return undef;
          }
          $cur = $cur->{PARENT} || die;
          DEBUG "config: context changed to: $cur->{CONTEXT}";
        }
        # be very strict about file options, for security sake
        return undef unless(check_file($value, { relative => 1 }, $key, $file));
        $value =~ s/\/+$//;    # remove trailing slash
        $value =~ s/^\/+//;    # remove leading slash
        if($value =~ /\//) {
          ERROR "Subvolume contains slashes: \"$value\" in \"$file\" line $.";
          return undef;
        }

        DEBUG "config: adding subvolume \"$value\" to volume context: $cur->{url}";
        my $subvolume = { CONTEXT => "subvolume",
                          PARENT => $cur,
                          rel_path => $value,
                          url => $cur->{url} . '/' . $value,
                         };
        $cur->{SUBVOLUME} //= [];
        push(@{$cur->{SUBVOLUME}}, $subvolume);
        $cur = $subvolume;
      }
      elsif($key eq "target")
      {
        if($cur->{CONTEXT} eq "target") {
          $cur = $cur->{PARENT} || die;
          DEBUG "config: context changed to: $cur->{CONTEXT}";
        }
        if($cur->{CONTEXT} ne "subvolume") {
          ERROR "Target keyword outside subvolume context, in \"$file\" line $.";
          return undef;
        }
        if($value =~ /^(\S+)\s+(\S+)$/)
        {
          my ($target_type, $droot) = ($1, $2);
          unless(grep(/^$target_type$/, @config_target_types)) {
            ERROR "Unknown target type \"$target_type\" in \"$file\" line $.";
            return undef;
          }
          # be very strict about file options, for security sake
          return undef unless(check_file($droot, { absolute => 1, ssh => 1 }, $key, $file));

          $droot =~ s/\/+$//;   # remove trailing slash
          $droot =~ s/^\/+/\//; # sanitize leading slash
          DEBUG "config: adding target \"$droot\" (type=$target_type) to subvolume context: $cur->{url}";
          my $target = { CONTEXT => "target",
                         PARENT => $cur,
                         target_type => $target_type,
                         url => $droot,
                       };
          $cur->{TARGET} //= [];
          push(@{$cur->{TARGET}}, $target);
          $cur = $target;
        }
        else
        {
          ERROR "Ambiguous target configuration, in \"$file\" line $.";
          return undef;
        }
      }
      elsif(grep(/^$key$/, keys %config_options))  # accept only keys listed in %config_options
      {
        if(grep(/^$value$/, @{$config_options{$key}->{accept}})) {
          TRACE "option \"$key=$value\" found in accept list";
        }
        elsif($config_options{$key}->{accept_numeric} && ($value =~ /^[0-9]+$/)) {
          TRACE "option \"$key=$value\" is numeric, accepted";
        }
        elsif($config_options{$key}->{accept_file})
        {
          # be very strict about file options, for security sake
          return undef unless(check_file($value, $config_options{$key}->{accept_file}, $key, $file));

          TRACE "option \"$key=$value\" is a valid file, accepted";
          $value =~ s/\/+$//;   # remove trailing slash
          $value =~ s/^\/+/\//; # sanitize leading slash
        }
        elsif($config_options{$key}->{accept_regexp}) {
          my $match = $config_options{$key}->{accept_regexp};
          if($value =~ m/$match/) {
            TRACE "option \"$key=$value\" matched regexp, accepted";
          }
          else {
            ERROR "Value \"$value\" failed input validation for option \"$key\" in \"$file\" line $.";
            return undef;
          }
        }
        else
        {
          ERROR "Unsupported value \"$value\" for option \"$key\" in \"$file\" line $.";
          return undef;
        }

        if($config_options{$key}->{context} && !grep(/^$cur->{CONTEXT}$/, @{$config_options{$key}->{context}})) {
          ERROR "Option \"$key\" is only allowed in " . join(" or ", map("\"$_\"", @{$config_options{$key}->{context}})) . " context, in \"$file\" line $.";
          return undef;
        }

        DEBUG "config: adding option \"$key=$value\" to $cur->{CONTEXT} context";
        $value = undef if($value eq "no");  # we don't want to check for "no" all the time
        $cur->{$key} = $value;

        if($config_options{$key}->{deprecated}) {
          WARN "Found deprecated configuration option \"$key\" in \"$file\" line $.";
        }
      }
      else
      {
        ERROR "Unknown option \"$key\" in \"$file\" line $.";
        return undef;
      }

      TRACE "line processed: new context=$cur->{CONTEXT}";
    }
    else
    {
      ERROR "Parse error in \"$file\" line $.";
      return undef;
    }
  }

  TRACE(Data::Dumper->Dump([$root], ["config_root"]));
  return $root;
}


sub btr_filesystem_show_all_local()
{
  return run_cmd("/sbin/btrfs filesystem show", 1);
}


sub btr_filesystem_show($)
{
  my $vol = shift || die;
  my $path = $vol->{PATH} // die;
  my $rsh = $vol->{RSH} || "";
  my $ret = run_cmd("$rsh /sbin/btrfs filesystem show $path", 1);
  return $ret;
}


sub btr_filesystem_df($)
{
  my $vol = shift || die;
  my $path = $vol->{PATH} // die;
  my $rsh = $vol->{RSH} || "";
  my $ret = run_cmd("$rsh /sbin/btrfs filesystem df $path", 1);
  return $ret;
}


sub btr_filesystem_usage($)
{
  my $vol = shift || die;
  my $path = $vol->{PATH} // die;
  my $rsh = $vol->{RSH} || "";
  my $ret = run_cmd("$rsh /sbin/btrfs filesystem usage $path", 1);
  return $ret;
}


sub btr_subvolume_detail($)
{
  my $vol = shift || die;
  my $path = $vol->{PATH} // die;
  my $rsh = $vol->{RSH} || "";
  my $vol_print = $vol->{PRINT} || $path;  # used only for logging
  my $ret = run_cmd("$rsh /sbin/btrfs subvolume show $path 2>/dev/null", 1);
  if($ret)
  {
    my $real_path;
    if($ret =~ /^($file_match)/) {
      $real_path = $1;
      DEBUG "Real path for subvolume \"$vol_print\" is: $real_path" if($real_path ne $path);
      return undef unless(check_file($real_path, { absolute => 1 }));
    }
    else {
      $real_path = $path;
      WARN "No real path provided by \"btrfs subvolume show\" for subvolume \"$vol_print\", using: $path";
    }
    my %detail = ( REAL_PATH  => $real_path );

    if($ret eq "$real_path is btrfs root") {
      DEBUG "found btrfs root: $vol_print";
      $detail{id}      = 5;
      $detail{is_root} = 1;
    }
    elsif($ret =~ /^$real_path/) {
      TRACE "btr_detail: found btrfs subvolume: $vol_print";
      my %trans = (
        name          => "Name",
        uuid          => "uuid",
        parent_uuid   => "Parent uuid",
        creation_time => "Creation time",
        id            => "Object ID",
        gen           => "Generation \\(Gen\\)",
        cgen          => "Gen at creation",
        parent_id     => "Parent",
        top_level     => "Top Level",
        flags         => "Flags",
       );
      foreach (keys %trans) {
        if($ret =~ /^\s+$trans{$_}:\s+(.*)$/m) {
          $detail{$_} = $1;
        } else {
          WARN "Failed to parse subvolume detail \"$trans{$_}\": $ret";
        }
      }
      DEBUG "parsed " . scalar(keys %detail) . " subvolume detail items: $vol_print";
      TRACE "btr_detail for $vol_print: " . Dumper \%detail;
    }
    return \%detail;
  }
  return undef;
}


sub btr_subvolume_list($;@)
{
  my $vol = shift || die;
  my %opts = @_;
  my $path = $vol->{PATH} // die;
  my $rsh = $vol->{RSH} || "";
  my $vol_print = $vol->{PRINT} || $path;  # used only for logging
  my $btrfs_progs_compat = $vol->{BTRFS_PROGS_COMPAT} || $opts{btrfs_progs_compat};
  my $filter_option = "-a";
  $filter_option = "-o" if($opts{subvol_only});
  my $display_options = "-c -u -q";
  $display_options .= " -R" unless($btrfs_progs_compat);
  my $ret = run_cmd("$rsh /sbin/btrfs subvolume list $filter_option $display_options $path", 1);
  unless(defined($ret)) {
    WARN "Failed to fetch btrfs subvolume list for: $vol_print";
    return undef;
  }
  my @nodes;
  foreach (split(/\n/, $ret))
  {
    # ID <ID> top level <ID> path <path> where path is the relative path
    # of the subvolume to the top level subvolume. The subvolume?s ID may
    # be used by the subvolume set-default command, or at mount time via
    # the subvolid= option. If -p is given, then parent <ID> is added to
    # the output between ID and top level. The parent?s ID may be used at
    # mount time via the subvolrootid= option.

    # NOTE: btrfs-progs prior to v1.17 do not support the -R flag
    my %node;
    if($btrfs_progs_compat) {
      die("Failed to parse line: \"$_\"") unless(/^ID ([0-9]+) gen ([0-9]+) cgen ([0-9]+) top level ([0-9]+) parent_uuid ([0-9a-z-]+) uuid ([0-9a-z-]+) path (.+)$/);
      %node = (
        id            => $1,
        gen           => $2,
        cgen          => $3,
        top_level     => $4,
        parent_uuid   => $5, # note: parent_uuid="-" if no parent
        # received_uuid => $6,
        uuid          => $6,
        path          => $7  # btrfs path, NOT filesystem path
     );
    } else {
      die("Failed to parse line: \"$_\"") unless(/^ID ([0-9]+) gen ([0-9]+) cgen ([0-9]+) top level ([0-9]+) parent_uuid ([0-9a-z-]+) received_uuid ([0-9a-z-]+) uuid ([0-9a-z-]+) path (.+)$/);
      %node = (
      id            => $1,
      gen           => $2,
      cgen          => $3,
      top_level     => $4,
      parent_uuid   => $5, # note: parent_uuid="-" if no parent
      received_uuid => $6,
      uuid          => $7,
      path          => $8  # btrfs path, NOT filesystem path
     );
    }

    # NOTE: "btrfs subvolume list <path>" prints <FS_TREE> prefix only if
    # the subvolume is reachable within <path>. (as of btrfs-progs-3.18.2)
    #
    # NOTE: Be prepared for this to change in btrfs-progs!
    $node{path} =~ s/^<FS_TREE>\///;     # remove "<FS_TREE>/" portion from "path".

    push @nodes, \%node;
    # $node{parent_uuid} = undef if($node{parent_uuid} eq '-');
  }
  DEBUG "parsed " . scalar(@nodes) . " total subvolumes for filesystem at: $vol_print";
  return \@nodes;
}


sub btr_subvolume_find_new($$;$)
{
  my $url = shift || die;
  my $lastgen = shift // die;
  my $config = shift;
  my ($rsh, $real_vol) = get_rsh($url, $config);
  my $ret = run_cmd("$rsh /sbin/btrfs subvolume find-new $real_vol $lastgen");
  unless(defined($ret)) {
    ERROR "Failed to fetch modified files for: $url";
    return undef;
  }

  my %files;
  my $parse_errors = 0;
  my $transid_marker;
  foreach (split(/\n/, $ret))
  {
    if(/^inode \S+ file offset (\S+) len (\S+) disk start \S+ offset \S+ gen (\S+) flags (\S+) (.+)$/) {
      my $file_offset = $1;
      my $len         = $2;
      my $gen         = $3;
      my $flags       = $4;
      my $name        = $5;
      $files{$name}->{len} += $len;
      $files{$name}->{new} = 1 if($file_offset == 0);
      $files{$name}->{gen}->{$gen} = 1;  # count the generations
      if($flags eq "COMPRESS") {
        $files{$name}->{flags}->{compress} = 1;
      }
      elsif($flags eq "COMPRESS|INLINE") {
        $files{$name}->{flags}->{compress} = 1;
        $files{$name}->{flags}->{inline} = 1;
      }
      elsif($flags eq "INLINE") {
        $files{$name}->{flags}->{inline} = 1;
      }
      elsif($flags eq "NONE") {
      }
      else {
        WARN "unparsed flags: $flags";
      }
    }
    elsif(/^transid marker was (\S+)$/) {
      $transid_marker = $1;
    }
    else {
      $parse_errors++;
    }
  }

  return { files => \%files,
           transid_marker => $transid_marker,
           parse_errors => $parse_errors,
          };
}


sub btr_tree($)
{
  my $vol = shift;
  my %tree;
  my %id;
  my $subvol_list = btr_subvolume_list($vol, subvol_only => 0);
  return undef unless(ref($subvol_list) eq "ARRAY");

  TRACE "btr_tree: processing subvolume list of: $vol->{URL}";

  foreach my $node (@$subvol_list)
  {
    $id{$node->{id}} = $node;
    $uuid_info{$node->{uuid}} = $node;

    my $rel_path = $node->{path};
    if($node->{top_level} == 5)
    {
      # man btrfs-subvolume:
      #   Also every btrfs filesystem has a default subvolume as its initially
      #   top-level subvolume, whose subvolume id is 5(FS_TREE).

      $tree{$node->{id}} = $node;
    }
    else
    {
      # set SUBTREE / PARENT node
      die unless exists($id{$node->{top_level}});
      my $parent = $id{$node->{top_level}};

      die if exists($parent->{SUBTREE}->{$node->{id}});
      $parent->{SUBTREE}->{$node->{id}} = $node;
      $node->{PARENT} = $parent;

      # "path" always starts with set REL_PATH
      die unless($rel_path =~ s/^$parent->{path}\///);
    }
    $node->{REL_PATH} = $rel_path;  # relative to {PARENT}->{path}
  }

  # set PARENT node
  foreach (values %id){
    $_->{PARENT} = $uuid_info{$_->{parent_uuid}} if($_->{parent_uuid} ne "-");
  }
  return \%tree;
}


sub _subtree_list
{
  my $tree = shift;
  my $list = shift;
  my $prefix = shift;

  return $list unless $tree;  # silent ignore empty subtrees

  foreach(values %$tree) {
    my $path = $prefix . $_->{REL_PATH};
    push(@$list, { SUBVOL_PATH => $path,
                   node    => $_,
                 });

    # recurse into SUBTREE
    _subtree_list($_->{SUBTREE}, $list, $path . '/');
  }
  return $list;
}



# returns hash of:
#   SUBVOL_PATH  relative path to URL
#   URL          absolute path
#   node         href to tree node
#
# returns an empty hash if the subvolume at $url exists, but contains no subvolumes
# returns undef if the subvolume at $url does not exists
sub vinfo_read_subvolumes($)
{
  my $vol = shift || die;
  my $url = $vol->{URL} || die;

  my $tree = btr_tree($vol);
  return undef unless($tree);

  my $tree_root;
  if($vol->{is_root}) {
    $tree_root = $tree;
  }
  else {
    die unless $uuid_info{$vol->{uuid}};
    $uuid_fs_map{$vol->{uuid}}->{$url} = 1;
    $tree_root = $uuid_info{$vol->{uuid}}->{SUBTREE};
    unless($tree_root) {
      DEBUG "No subvolumes found in: $url";
      $vol->{SUBVOL_INFO} = {};
      return $vol;
    }
  }

  # recurse into $tree_root, returns list of href: { URL, node }
  my $list = _subtree_list($tree_root, [], "");

  # return a hash of relative subvolume path
  my %ret;
  foreach(@$list) {
    my $subvol_path = $_->{SUBVOL_PATH};
    die if exists $ret{$subvol_path};
    $_->{URL} = $url . '/' . $subvol_path;
    $_->{PATH} = $vol->{PATH} . '/' . $subvol_path;
    $_->{PRINT} = $vol->{PRINT} . '/' . $subvol_path;
    $_->{RSH} = $vol->{RSH};
    # !!! TODO: make real vinfo out of this
    $uuid_fs_map{$_->{node}->{uuid}}->{$url . '/' . $subvol_path} = 1;
    $ret{$subvol_path} = $_;
  }

  TRACE(Data::Dumper->Dump([\%ret], ["vol_info{$url}"]));

  $vol->{SUBVOL_INFO} = \%ret;
  return \%ret;
}


# returns $target, or undef on error
sub btrfs_snapshot($$)
{
  my $svol = shift || die;
  my $target_path = shift // die;
  my $src_path = $svol->{PATH} // die;
  my $rsh = $svol->{RSH} || "";
  DEBUG "[btrfs] snapshot (ro):";
  DEBUG "[btrfs]   host  : $svol->{HOST}" if($svol->{HOST});
  DEBUG "[btrfs]   source: $src_path";
  DEBUG "[btrfs]   target: $target_path";
  INFO ">>> " . ($svol->{HOST} ? "$svol->{HOST}:" : "") .  $target_path;
  my $ret = run_cmd("$rsh /sbin/btrfs subvolume snapshot -r $src_path $target_path");
  ERROR "Failed to create btrfs subvolume snapshot: $svol->{PRINT} -> $target_path" unless(defined($ret));
  return defined($ret) ? $target_path : undef;
}


sub btrfs_subvolume_delete($@)
{
  my $config = shift;
  my @targets = @_;
  return 0 unless(scalar(@targets));
  my @real_targets;
  my $rsh;
  foreach (@targets) {
    my ($r, $t) = get_rsh($_, $config);
    die if($rsh && ($rsh ne $r)); # make sure all targets share same ssh host
    $rsh = $r;
    push(@real_targets, $t);
  }
  die if(scalar(@targets) != scalar(@real_targets));
  my $commit_delete = config_key($config, "btrfs_commit_delete") // "";
  DEBUG "[btrfs] delete" . ($commit_delete ? " (commit-$commit_delete):" : ":");
  DEBUG "[btrfs]   subvolume: $_" foreach(@targets);
  my $options = "";
  $options = "--commit-after " if($commit_delete eq "after");
  $options = "--commit-each "  if($commit_delete eq "each");
  my $ret = run_cmd("$rsh /sbin/btrfs subvolume delete $options" . join(' ', @real_targets));
  ERROR "Failed to delete btrfs subvolumes: " . join(' ', @targets) unless(defined($ret));
  return defined($ret) ? scalar(@targets) : undef;
}


sub btrfs_send_receive($$$)
{
  my $snapshot = shift || die;
  my $target = shift || die;
  my $parent = shift;
  my $snapshot_path = $snapshot->{PATH} // die;
  my $snapshot_rsh  = $snapshot->{RSH} || "";
  my $target_path = $target->{PATH} // die;
  my $target_rsh  = $target->{RSH} || "";
  my $parent_path = $parent ? $parent->{PATH} : undef;

   my $snapshot_name = $snapshot_path;
   $snapshot_name =~ s/^.*\///;
  INFO ">>> $target->{PRINT}/$snapshot_name";

  DEBUG "[btrfs] send/receive" . ($parent ? " (incremental)" : " (complete)") . ":";
  DEBUG "[btrfs]   source: $snapshot->{PRINT}";
  DEBUG "[btrfs]   parent: $parent->{PRINT}" if($parent);
  DEBUG "[btrfs]   target: $target->{PRINT}";

  my $parent_option = $parent_path ? "-p $parent_path" : "";
  my $receive_option = "";
  $receive_option = "-v" if($loglevel >= 3);

  my $cmd = "$snapshot_rsh /sbin/btrfs send $parent_option $snapshot_path | $target_rsh /sbin/btrfs receive $receive_option $target_path/";
  my $ret = run_cmd($cmd);
  unless(defined($ret)) {
    ERROR "Failed to send/receive btrfs subvolume: $snapshot->{PRINT} " . ($parent_path ? "[$parent_path]" : "") . " -> $target->{PRINT}";
    return undef;
  }
  return 1;
}


# sets $config->{ABORTED} on failure
# sets $config->{subvol_received}
sub macro_send_receive($@)
{
  my $config = shift || die;
  my %info = @_;
  my $snapshot = $info{snapshot} || die;
  my $target = $info{target} || die;
  my $parent = $info{parent};
  my $incremental = config_key($config, "incremental");

  INFO "Receiving from snapshot: $snapshot->{PRINT}";

  # add info to $config->{subvol_received}
  $info{received_name} = $snapshot->{PRINT};
  $config->{subvol_received} //= [];
  push(@{$config->{subvol_received}}, \%info);

  if($incremental)
  {
    # create backup from latest common
    if($parent) {
      INFO "Incremental from parent snapshot: $parent";
    }
    elsif($incremental ne "strict") {
      INFO "No common parent subvolume present, creating full backup";
    }
    else {
      WARN "Backup to $target->{PRINT} failed: no common parent subvolume found, and option \"incremental\" is set to \"strict\"";
      $info{ERROR} = 1;
      $config->{ABORTED} = "No common parent subvolume found, and option \"incremental\" is set to \"strict\"";
      return undef;
    }
  }
  else {
    INFO "Option \"incremental\" is not set, creating full backup";
    delete $info{parent};
  }

  if(btrfs_send_receive($snapshot, $target, $parent)) {
    return 1;
  } else {
    $info{ERROR} = 1;
    $config->{ABORTED} = "btrfs send/receive command failed";
    return undef;
  }
}


sub get_date_tag($)
{
  my $name = shift;
  $name =~ s/_([0-9]+)$//;
  my $postfix_counter = $1 // 0;
  my $date = undef;
  if($name =~ /\.([0-9]{4})([0-9]{2})([0-9]{2})$/) {
    $date = [ $1, $2, $3 ];
  }
  return ($date, $postfix_counter);
}


sub get_snapshot_children($$)
{
  my $sroot = shift || die;  # TODO: this should be second argument, as we return all snap children from svol under sroot
  my $svol = shift // die;
  my @ret;
  foreach (values %{$sroot->{SUBVOL_INFO}}) {
    next unless($_->{node}->{parent_uuid} eq $svol->{uuid});
    TRACE "get_snapshot_children: found: $_->{URL}";
    push(@ret, $_);
  }
  DEBUG "Found " . scalar(@ret) . " snapshot children of: $svol->{URL}";
  return @ret;
}


sub get_receive_targets($$)
{
  my $droot = shift || die;
  my $src_href = shift || die;
  die("root subvolume info not present: $droot") unless($droot->{SUBVOL_INFO});
  my @ret;

  if($droot->{BTRFS_PROGS_COMPAT})
  {
    # guess matches by subvolume name (node->received_uuid is not available if BTRFS_PROGS_COMPAT is set)
    DEBUG "Fallback to compatibility mode (get_receive_targets)";
    my $src_name = $src_href->{node}->{REL_PATH};
    $src_name =~ s/^.*\///; # strip path
    foreach my $target (values %{$droot->{SUBVOL_INFO}}) {
      my $target_name = $target->{node}->{REL_PATH};
      $target_name =~ s/^.*\///; # strip path
      if($target_name eq $src_name) {
        TRACE "get_receive_targets: by-name: Found receive target: $target->{SUBVOL_PATH}";
        push(@ret, $target);
      }
    }
  }
  else
  {
    # find matches by comparing uuid / received_uuid
    my $uuid = $src_href->{node}->{uuid};
    die("subvolume info not present: $uuid") unless($uuid_info{$uuid});
    foreach (values %{$droot->{SUBVOL_INFO}}) {
      next unless($_->{node}->{received_uuid} eq $uuid);
      TRACE "get_receive_targets: by-uuid: Found receive target: $_->{SUBVOL_PATH}";
      push(@ret, $_);
    }
  }
  DEBUG "Found " . scalar(@ret) . " receive targets in \"$droot->{URL}/\" for: $src_href->{URL}";
  return @ret;
}


sub get_latest_common($$$;$)
{
  my $sroot = shift || die;
  my $svol = shift // die;
  my $droot = shift || die;
  my $threshold_gen = shift;  # skip all snapshot children with generation >= $threshold_gen

  die("source subvolume info not present: $sroot->{URL}") unless($sroot->{URL});
  die("target subvolume info not present: $droot->{URL}") unless($droot->{URL});

  my $debug_src = $svol->{URL};
  $debug_src .= "#" . $threshold_gen if($threshold_gen);

  # sort children of svol descending by generation
  foreach my $child (sort { $b->{node}->{gen} <=> $a->{node}->{gen} } get_snapshot_children($sroot, $svol)) {
    TRACE "get_latest_common: checking source snapshot: $child->{SUBVOL_PATH}";
    if($threshold_gen && ($child->{node}->{gen} >= $threshold_gen)) {
      TRACE "get_latest_common: skipped gen=$child->{node}->{gen} >= $threshold_gen: $child->{SUBVOL_PATH}";
      next;
    }

    if($child->{RECEIVE_TARGET_PRESENT} && ($child->{RECEIVE_TARGET_PRESENT} eq $droot->{URL})) {
      # little hack to keep track of previously received subvolumes
      DEBUG("Latest common snapshots for: $debug_src: src=$child->{URL}  target=<previously received>");
      return ($child, undef);
    }

    foreach (get_receive_targets($droot, $child)) {
      TRACE "get_latest_common: found receive target: $_->{URL}";
      DEBUG("Latest common snapshots for: $debug_src: src=$child->{URL}  target=$_->{URL}");
      return ($child, $_);
    }
    TRACE "get_latest_common: no matching targets found for: $child->{URL}";
  }
  DEBUG("No common snapshots for \"$debug_src\" found in src=$sroot->{URL}/  target=$droot->{URL}/");
  return (undef, undef);
}


sub _origin_tree
{
  my $prefix = shift;
  my $uuid = shift;
  my $lines = shift;
  my $node = $uuid_info{$uuid};
  unless($node) {
    push(@$lines, ["$prefix<orphaned>", $uuid]);
    return 0;
  }
  if($uuid_fs_map{$uuid}) {
    foreach(keys %{$uuid_fs_map{$uuid}}) {
      push(@$lines, ["$prefix$_", $uuid]);
    }
  } else {
    push(@$lines, ["$prefix<BTRFS_ROOT>/$node->{path}", $uuid]);
  }

  $prefix =~ s/./ /g;
  if($node->{received_uuid}) {
    if($node->{received_uuid} ne '-') {
      _origin_tree("${prefix}^---", $node->{received_uuid}, $lines);
    }
  } else {
    push(@$lines,  ["$prefix^---<missing_received_uuid>", $uuid]);  # printed if "btrfs_progs_compat" is set
  }
  if($node->{parent_uuid} ne '-') {
    _origin_tree("${prefix}", $node->{parent_uuid}, $lines);
  }
}


sub schedule(@)
{
  my %args = @_;
  my $schedule             = $args{schedule}             || die;
  my @today                = @{$args{today}};
  my $preserve_day_of_week = $args{preserve_day_of_week} || die;
  my $preserve_daily       = $args{preserve_daily}       // die;
  my $preserve_weekly      = $args{preserve_weekly}      // die;
  my $preserve_monthly     = $args{preserve_monthly}     // die;
  my $log_verbose          = $args{log_verbose};

  if($log_verbose) {
    INFO "Filter scheme: preserving all within $preserve_daily days";
    INFO "Filter scheme: preserving first in week (starting on $preserve_day_of_week), for $preserve_weekly weeks";
    INFO "Filter scheme: preserving last weekly of month, for $preserve_monthly months";
  }

  # sort the schedule, ascending by date
  my @sorted_schedule = sort { ($a->{date}->[0] <=> $b->{date}->[0]) ||
                               ($a->{date}->[1] <=> $b->{date}->[1]) ||
                               ($a->{date}->[2] <=> $b->{date}->[2]) ||
                               ($a->{date_ext}  <=> $a->{date_ext})
                             } @$schedule;

  # first, do our calendar calculations
  # note: our week starts on $preserve_day_of_week
  my $delta_days_to_eow_from_today = $day_of_week_map{$preserve_day_of_week} - Day_of_Week(@today) - 1;
  $delta_days_to_eow_from_today = $delta_days_to_eow_from_today + 7 if($delta_days_to_eow_from_today < 0);
  TRACE "last day before next $preserve_day_of_week is in $delta_days_to_eow_from_today days";
  foreach my $href (@sorted_schedule)
  {
    my @date = @{$href->{date}};
    my $delta_days = Delta_Days(@date, @today);
    my $delta_days_to_eow = $delta_days + $delta_days_to_eow_from_today;
    {
      use integer; # do integer arithmetics
      $href->{delta_days}   = $delta_days;
      $href->{delta_weeks}  = $delta_days_to_eow / 7;
      $href->{err_days}     = 6 - ( $delta_days_to_eow % 7 );
      $href->{delta_months} = ($today[0] - $date[0]) * 12 + ($today[1] - $date[1]);
      $href->{month}        = "$date[0]-$date[1]";
    }
  }

  # filter daily, weekly, monthly
  my %first_in_delta_weeks;
  my %last_weekly_in_delta_months;
  foreach my $href (@sorted_schedule) {
    if($preserve_daily && (($preserve_daily eq "all") || ($href->{delta_days} <= $preserve_daily))) {
      $href->{preserve} ||= "preserved daily: $href->{delta_days} days ago";
    }
    $first_in_delta_weeks{$href->{delta_weeks}} //= $href;
  }
  foreach (reverse sort keys %first_in_delta_weeks) {
    my $href = $first_in_delta_weeks{$_} || die;
    if($preserve_weekly && (($preserve_weekly eq "all") || ($href->{delta_weeks} <= $preserve_weekly))) {
      $href->{preserve} ||= "preserved weekly: $href->{delta_weeks} weeks ago, " . ($href->{err_days} ? "+$href->{err_days} days after " : "on ") . "$preserve_day_of_week";
    }
    $last_weekly_in_delta_months{$href->{delta_months}} = $href;
  }
  foreach (reverse sort keys %last_weekly_in_delta_months) {
    my $href = $last_weekly_in_delta_months{$_} || die;
    if($preserve_monthly && (($preserve_monthly eq "all") || ($href->{delta_months} <= $preserve_monthly))) {
      $href->{preserve} ||= "preserved monthly: " . ($href->{err_days} ? "$href->{err_days} days after " : "") . "last $preserve_day_of_week of month $href->{month} (age: $href->{delta_months} months)";
    }
  }

  # assemble results
  my @delete;
  my @preserve;
  foreach my $href (@sorted_schedule)
  {
    if($href->{preserve}) {
      INFO "=== $href->{name}: $href->{preserve}" if($href->{name});
      push(@preserve, $href->{value});
    }
    else {
      INFO "<<< $href->{name}" if($href->{name});
      push(@delete, $href->{value});
    }
  }
  DEBUG "Preserving " . @preserve . "/" . @$schedule . " items" unless($log_verbose);
  return (\@preserve, \@delete);
}


MAIN:
{
  $ENV{PATH} = '';
  $Getopt::Std::STANDARD_HELP_VERSION = 1;
  $Data::Dumper::Sortkeys = 1;
  my $start_time = time;
  my @today = Today();

  my %opts;
  unless(getopts('hc:vql:p', \%opts)) {
    VERSION_MESSAGE();
    HELP_MESSAGE(0);
    exit 1;
  }
  my $command = shift @ARGV;

  # assign command line options
  $loglevel = $opts{l} || "";
  if   (lc($loglevel) eq "warn")  { $loglevel = 1; }
  elsif(lc($loglevel) eq "info")  { $loglevel = 2; }
  elsif(lc($loglevel) eq "debug") { $loglevel = 3; }
  elsif(lc($loglevel) eq "trace") { $loglevel = 4; }
  elsif($loglevel =~ /^[0-9]+$/) { ; }
  else {
    $loglevel = $opts{v} ? 2 : 1;
  }
  @config_src = ( $opts{c} ) if($opts{c});
  my $quiet = $opts{q};
  my $preserve_backups = $opts{p};

  # check command line options
  if($opts{h} || (not $command)) {
    VERSION_MESSAGE();
    HELP_MESSAGE(0);
    exit 0;
  }

  my ($action_run, $action_info, $action_tree, $action_diff, $action_origin);
  my @subvol_args;
  my ($args_expected_min, $args_expected_max) = (0, 0);
  if(($command eq "run") || ($command eq "dryrun")) {
    $action_run = 1;
    $dryrun = 1 if($command eq "dryrun");
    $args_expected_min = 0;
    $args_expected_max = 9999;
    @subvol_args = @ARGV;
  }
  elsif ($command eq "info") {
    $action_info = 1;
  }
  elsif ($command eq "tree") {
    $action_tree = 1;
  }
  elsif ($command eq "diff") {
    $action_diff = 1;
    $args_expected_min = $args_expected_max = 2;
    @subvol_args = @ARGV;
  }
  elsif ($command eq "origin") {
    $action_origin = 1;
    $args_expected_min = $args_expected_max = 1;
    @subvol_args = @ARGV;
  }
  else {
    ERROR "Unrecognized command: $command";
    HELP_MESSAGE(0);
    exit 1;
  }
  if(($args_expected_min > scalar(@ARGV)) || ($args_expected_max < scalar(@ARGV))) {
    ERROR "Incorrect number of arguments";
    HELP_MESSAGE(0);
    exit 1;
  }

  # input validation
  foreach (@subvol_args) {
    s/\/+$//;   # remove trailing slash
    unless(/^(($ssh_prefix_match)?\/$file_match)$/) {  # matches ssh statement or absolute file
      ERROR "Bad argument: not a subvolume declaration: $_";
      HELP_MESSAGE(0);
      exit 1;
    }
    $_ = $1; # untaint argument
  }


  INFO "$version_info  (" . localtime($start_time) . ")";

  if($action_diff)
  {
    #
    # print snapshot diff
    #
    my $src_vol    = $subvol_args[0] || die;
    my $target_vol = $subvol_args[1] || die;
    # FIXME: allow ssh:// src/dest (does not work since the configuration is not yet read).

    my $src_detail = vinfo($src_vol);
    unless($src_detail) { exit 1; }
    if($src_detail->{is_root})  { ERROR "subvolume at \"$src_vol\" is btrfs root!"; exit 1; }
    unless($src_detail->{cgen}) { ERROR "subvolume at \"$src_vol\" does not provide cgen"; exit 1; }
#    if($src_detail->{parent_uuid} eq "-") { ERROR "subvolume at \"$src_vol\" has no parent, aborting."; exit 1; }

    my $target_detail = vinfo($target_vol);
    unless($target_detail) { exit 1; }
    unless($src_detail->{cgen}) { ERROR "subvolume at \"$src_vol\" does not provide cgen"; exit 1; }
#    if($src_detail->{parent_uuid} eq "-") { ERROR "subvolume at \"$src_vol\" has no parent, aborting."; exit 1; }

    my $info = btr_tree($src_vol);
    my $src = $uuid_info{$src_detail->{uuid}} || die;
    my $target = $uuid_info{$target_detail->{uuid}};
    unless($target) { ERROR "target subvolume is not on the same btrfs filesystem!"; exit 1; }

    my $lastgen;

    # check if given src and target share same parent
    if(ref($src->{PARENT}) && ($src->{PARENT}->{uuid} eq $target->{uuid})) {
      DEBUG "target subvolume is direct parent of source subvolume";
    }
    elsif(ref($src->{PARENT}) && ref($target->{PARENT}) && ($src->{PARENT}->{uuid} eq $target->{PARENT}->{uuid})) {
      DEBUG "target subvolume and source subvolume share same parent";
    }
    else {
      # TODO: this rule only applies to snapshots. find a way to distinguish snapshots from received backups
      # ERROR "subvolumes \"$target_vol\" and \"$src_vol\" do not share the same parents";
      # exit 1;
    }

    # NOTE: in some cases "cgen" differs from "gen", even for read-only snapshots (observed: gen=cgen+1)
    $lastgen = $src->{cgen} + 1;

    # dump files, sorted and unique
    my $ret = btr_subvolume_find_new($target_vol, $lastgen);
    exit 1 unless(ref($ret));

    print "--------------------------------------------------------------------------------\n";
    print "Showing changed files for subvolume:\n  $target->{path}  (gen=$target->{gen})\n";
    print "\nStarting at creation generation from subvolume:\n  $src->{path}  (cgen=$src->{cgen})\n";
    print "\nThis will show all files modified within generation range: [$lastgen..$target->{gen}]\n";
    print "Newest file generation (transid marker) was: $ret->{transid_marker}\n";
    print "Parse errors: $ret->{parse_errors}\n" if($ret->{parse_errors});
    print "\nLegend: <flags> <count> <size> <filename>\n";
    print "  +..     file accessed at offset 0 (at least once)\n";
    print "  .c.     flags COMPRESS or COMPRESS|INLINE set (at least once)\n";
    print "  ..i     flags INLINE or COMPRESS|INLINE set (at least once)\n";
    print "  <count> file was modified in <count> generations\n";
    print "  <size>  file was modified for a total of <size> bytes\n";
    print "--------------------------------------------------------------------------------\n";
    my $files = $ret->{files};

    # calculate the character offsets
    my $len_charlen = 0;
    my $gen_charlen = 0;
    foreach (values %$files) {
      my $len = length($_->{len});
      my $gen = length(scalar(keys(%{$_->{gen}})));
      $len_charlen = $len if($len > $len_charlen);
      $gen_charlen = $gen if($gen > $gen_charlen);
    }

    # finally print the output
    foreach my $name (sort keys %$files) {
      print ($files->{$name}->{new}               ? '+' : '.');
      print ($files->{$name}->{flags}->{compress} ? 'c' : '.');
      print ($files->{$name}->{flags}->{inline}   ? 'i' : '.');

      # make nice table
      my $gens = scalar(keys(%{$files->{$name}->{gen}}));
      my $len = $files->{$name}->{len};
      print "  " . (' ' x ($gen_charlen - length($gens))) .  $gens;
      print "  " . (' ' x ($len_charlen - length($len))) .  $len;

      print "  $name\n";
    }

    exit 0;
  }


  #
  # parse config file
  #
  my $config = parse_config(@config_src);
  unless($config) {
    ERROR "Failed to parse configuration file";
    exit 1;
  }
  unless(ref($config->{VOLUME}) eq "ARRAY") {
    ERROR "No volumes defined in configuration file";
    exit 1;
  }



  if($action_info)
  {
    #
    # print filesystem information
    #
    print "================================================================================\n";
    print "Filesystem information ($version_info)\n\n";
    print "    Date:   " . localtime($start_time) . "\n";
    print "    Config: $config->{SRC_FILE}\n";
    print "================================================================================\n";

    # print "\n--------------------------------------------------------------------------------\n";
    # print "All local btrfs filesystems\n";
    # print "--------------------------------------------------------------------------------\n";
    # print (btr_filesystem_show_all_local() // "");
    # print "\n";

    my %processed;
    foreach my $config_vol (@{$config->{VOLUME}})
    {
      my $url = $config_vol->{url} || die;
      unless($processed{$url})
      {
        print "\n--------------------------------------------------------------------------------\n";
        print "Source volume: $url\n";
        print "--------------------------------------------------------------------------------\n";
        # print (btr_filesystem_show(vinfo($url, $config_vol)) // "");
        # print "\n\n";
        print (btr_filesystem_usage(vinfo($url, $config_vol)) // "");
        print "\n";
        $processed{$url} = 1;
      }
    }

    foreach my $config_vol (@{$config->{VOLUME}}) {
      my $sroot_url = $config_vol->{url} || die;
      foreach my $config_subvol (@{$config_vol->{SUBVOLUME}}) {
        foreach my $config_target (@{$config_subvol->{TARGET}})
        {
          my $droot_url = $config_target->{url} || die;
          unless($processed{$droot_url})
          {
            print "\n--------------------------------------------------------------------------------\n";
            print "Target volume: $droot_url\n";
            print "               ^--- $sroot_url\n";
            print "--------------------------------------------------------------------------------\n";
            print (btr_filesystem_usage(vinfo($droot_url, $config_target)) // "");
            print "\n";
            $processed{$droot_url} = 1;
          }
        }
      }
    }
    exit 0;
  }


  #
  # filter subvolumes matching command line arguments
  #
  if($action_run && scalar(@subvol_args))
  {
    my $filter_count = undef;
    foreach my $config_vol (@{$config->{VOLUME}})
    {
      my $subvol_filter_count = 0;
      foreach my $config_subvol (@{$config_vol->{SUBVOLUME}})
      {
        my $svol_url = $config_subvol->{url} // die;
        if(grep(/^\Q$svol_url\E$/, @subvol_args)) {
          $subvol_filter_count++;
        }
        else {
          DEBUG "No match on subvolume command line argument, skipping: $svol_url";
          $config_subvol->{ABORTED} = "No match on subvolume command line arguments";
          $config_subvol->{ABORTED_NOERR} = 1;
          next;
        }
      }
      if($subvol_filter_count == 0) {
        $config_vol->{ABORTED} = "No match on subvolume command line arguments";
        $config_vol->{ABORTED_NOERR} = 1;
      }
      $filter_count += $subvol_filter_count;
    }
    if($filter_count == 0) {
      ERROR "Subvolume command line arguments do not match any volume/subvolume declaration from configuration file, aborting.";
      exit 1;
    }
  }


  #
  # fill vol_info hash, basic checks on configuration
  #
  my %snapshot_check;
  foreach my $config_vol (@{$config->{VOLUME}})
  {
    next if($config_vol->{ABORTED});
    my $sroot = vinfo($config_vol->{url}, $config_vol);
    unless(vinfo_read_detail($sroot)) {
      $config_vol->{ABORTED} = "Failed to fetch subvolume detail";
      WARN "Skipping volume \"$sroot->{URL}\": $config_vol->{ABORTED}";
      next;
    }

    foreach my $config_subvol (@{$config_vol->{SUBVOLUME}})
    {
      next if($config_subvol->{ABORTED});
      my $svol = vinfo($config_subvol->{url}, $config_vol);

      # check for duplicate snapshot locations
      my $snapdir = config_key($config_subvol, "snapshot_dir") || "";
      my $snapshot_basename = config_key($config_subvol, "snapshot_name") // $svol->{NAME} // die;
      my $snapshot_target = "$sroot->{REAL_URL}/$snapdir/$snapshot_basename";
      if(my $prev = $snapshot_check{$snapshot_target}) {
        ERROR "Subvolume \"$prev\" and \"$svol->{PRINT}\" will create same snapshot: $snapshot_target";
        ERROR "Please fix \"snapshot_name\" configuration options!";
        exit 1;
      }
      $snapshot_check{$snapshot_target} = $svol->{PRINT};

      # read subvolume detail
      unless(vinfo_read_detail($svol)) {
        $config_subvol->{ABORTED} = "Failed to fetch subvolume detail";
        WARN "Skipping subvolume \"$svol->{URL}\": $config_subvol->{ABORTED}";
        next;
      }
      unless(vinfo_read_subvolumes($sroot)) {
        $config_subvol->{ABORTED} = "Failed to fetch subvolume list";
        WARN "Skipping subvolume \"$svol->{URL}\": $config_subvol->{ABORTED}";
        next;
      }

      unless(subvol($sroot, $config_subvol->{rel_path})) {  # !!! TODO: check uuid here!
        $config_subvol->{ABORTED} = "Subvolume \"$svol->{URL}\" not present in btrfs subvolume list for \"$sroot->{URL}\"";
        WARN "Skipping subvolume \"$svol->{URL}\": $config_subvol->{ABORTED}";
        next;
      }
      foreach my $config_target (@{$config_subvol->{TARGET}})
      {
        my $droot = vinfo($config_target->{url}, $config_target);
        unless(vinfo_read_detail($droot)) {
          $config_target->{ABORTED} = "Failed to fetch subvolume detail";
          WARN "Skipping target \"$droot->{URL}\": $config_target->{ABORTED}";
          next;
        }

        # check for duplicate snapshot locations
        my $snapshot_backup_target = "$droot->{REAL_URL}/$snapshot_basename";
        if(my $prev = $snapshot_check{$snapshot_backup_target}) {
          ERROR "Subvolume \"$prev\" and \"$svol->{PRINT}\" will create same snapshot: $snapshot_target";
          ERROR "Please fix \"snapshot_name\" configuration options!";
          exit 1;
        }
        $snapshot_check{$snapshot_backup_target} = $svol->{PRINT};

        unless(vinfo_read_subvolumes($droot)) {
          $config_target->{ABORTED} = "Failed to fetch subvolume list";
          WARN "Skipping target \"$droot->{URL}\": $config_target->{ABORTED}";
          next;
        }
      }
    }
  }


  if($action_origin)
  {
    #
    # print origin information
    #
    my $url = $subvol_args[0] || die;
    my $dump_uuid = 0;

    my $vol = vinfo($url);
    exit 1 unless($vol);

    if($vol->{is_root}) {
      ERROR "Subvolume is btrfs root: $url\n";
      exit 1;
    }
    my $uuid = $vol->{uuid} || die;
    my $node = $uuid_info{$uuid};

    unless($node) {  # !!! TODO: fix this
      DEBUG "Subvolume not parsed yet, fetching info: $url";
# !!!      $vol_info{$url} //= btr_fs_info($vol);
      $node = $uuid_info{$uuid} || die;
    }

    my $lines = [];
    _origin_tree("", $uuid, $lines);

    print "--------------------------------------------------------------------------------\n";
    print "Origin Tree\n\n";
    print "    ^---    : received from subvolume\n";
    print "    newline : parent subvolume\n";
    print "    orphaned: subvolume uuid could not be resolved (probably deleted)\n";
    print "--------------------------------------------------------------------------------\n";

    my $len = 0;
    if($dump_uuid) {
      $len = (length($_->[0]) > $len ? length($_->[0]) : $len) foreach(@$lines);
    }
    foreach(@$lines) {
      print "$_->[0]";
      print ' ' x ($len - length($_->[0]) + 4) . "$_->[1]" if($dump_uuid);
      print "\n";
    }
    exit 0;
  }


  if($action_tree)
  {
    #
    # print snapshot tree
    #
    # TODO: reverse tree: print all backups from $droot and their corresponding source snapshots
    foreach my $config_vol (@{$config->{VOLUME}})
    {
      my %droot_compat;
      my $sroot = vinfo($config_vol->{url}, $config_vol);
      print "$sroot->{URL}\n";
      next unless $sroot->{ERROR};  # !!! TODO: check this
      foreach my $config_subvol (@{$config_vol->{SUBVOLUME}})
      {
        my $svol = vinfo($config_subvol->{url}, $config_vol);
        print "|-- $svol->{URL}\n";
        unless(subvol($sroot, $config_subvol->{rel_path})) {  # !!! TODO: maybe check uuid here?
          print "    !!! error: no subvolume \"$config_subvol->{rel_path}\" found in \"$sroot->{URL}\"\n";
          next;
        }

        foreach my $snapshot (sort { $a->{SUBVOL_PATH} cmp $b->{SUBVOL_PATH} } (values %{$sroot->{SUBVOL_INFO}}))
        {
          next unless($snapshot->{node}->{parent_uuid} eq $svol->{uuid});
          # next unless($snapshot->{SUBVOL_PATH} =~ /^$snapdir/);  # don't print non-btrbk snapshots
          print "|   ^-- $snapshot->{SUBVOL_PATH}\n";
          foreach my $config_target (@{$config_subvol->{TARGET}})
          {
            my $droot = vinfo($config_target->{url}, $config_target);
            next unless $droot->{SUBVOL_INFO};
            $droot_compat{$droot} = 1 if($droot->{BTRFS_PROGS_COMPAT});
            foreach (sort { $a->{SUBVOL_PATH} cmp $b->{SUBVOL_PATH} } get_receive_targets($droot, $snapshot)) {
              print "|   |   ^== $_->{URL}\n";
            }
          }
        }
      }
      if(keys %droot_compat) {
        print "\nNOTE: Received subvolumes (backups) are guessed by subvolume name for targets:\n";
        print "      - " . join("\n      - ", (sort keys %droot_compat));
      }
      print "\n";
    }
    exit 0;
  }


  if($action_run)
  {
    #
    # create snapshots
    #
    my $timestamp = sprintf("%04d%02d%02d", @today);
    foreach my $config_vol (@{$config->{VOLUME}})
    {
      next if($config_vol->{ABORTED});
      my $sroot = vinfo($config_vol->{url});
      foreach my $config_subvol (@{$config_vol->{SUBVOLUME}})
      {
        next if($config_subvol->{ABORTED});
        my $svol = vinfo($config_subvol->{url});
        my $snapdir = config_key($config_subvol, "snapshot_dir") || "";
        my $snapshot_basename = config_key($config_subvol, "snapshot_name") // $svol->{NAME} // die;

        # check if we need to create a snapshot
        my $create_snapshot = config_key($config_subvol, "snapshot_create_always");
        foreach my $config_target (@{$config_subvol->{TARGET}}) {
          next if($config_target->{ABORTED});
          $create_snapshot = 1 if($config_target->{target_type} eq "send-receive");
        }
        unless($create_snapshot) {
          $config_subvol->{ABORTED} = "No targets defined for subvolume: $svol->{URL}";
          WARN "Skipping subvolume section: $config_subvol->{ABORTED}";
          next;
        }

        # find unique snapshot name
        my @lookup = keys %{$sroot->{SUBVOL_INFO}};
        @lookup = grep s/^\Q$snapdir\E\/// , @lookup;
        foreach my $config_target (@{$config_subvol->{TARGET}}) {
          my $droot = vinfo($config_target->{url});
          push(@lookup, keys %{$droot->{SUBVOL_INFO}});
        }
        @lookup = grep /^\Q$snapshot_basename.$timestamp\E(_[0-9]+)?$/ ,@lookup;
        TRACE "Present snapshot names for \"$svol->{URL}\": " . join(', ', @lookup);
        @lookup = map { /_([0-9]+)$/ ? $1 : 0 } @lookup;
        @lookup = sort { $b <=> $a } @lookup;
        my $postfix_counter = $lookup[0] // -1;
        $postfix_counter++;
        my $snapshot_name = $snapshot_basename . '.' . $timestamp . ($postfix_counter ? "_$postfix_counter" : "");

        # finally create the snapshot
        INFO "Creating subvolume snapshot for: $svol->{PRINT}";
        if(btrfs_snapshot($svol, "$sroot->{PATH}/$snapdir/$snapshot_name")) {
          $config_subvol->{SNAPSHOT} = vinfo("$sroot->{URL}/$snapdir/$snapshot_name", $config_vol);
        }
        else {
          $config_subvol->{ABORTED} = "Failed to create snapshot: $svol->{PRINT} -> $sroot->{PRINT}/$snapdir/$snapshot_name";
          WARN "Skipping subvolume section: $config_subvol->{ABORTED}";
        }
      }
    }

    #
    # create backups
    #
    foreach my $config_vol (@{$config->{VOLUME}})
    {
      next if($config_vol->{ABORTED});
      my $sroot = vinfo($config_vol->{url});
      foreach my $config_subvol (@{$config_vol->{SUBVOLUME}})
      {
        next if($config_subvol->{ABORTED});
        my $svol = vinfo($config_subvol->{url});
        my $snapdir = config_key($config_subvol, "snapshot_dir") || "";
        my $snapshot_basename = config_key($config_subvol, "snapshot_name") // $svol->{NAME} // die;

        foreach my $config_target (@{$config_subvol->{TARGET}})
        {
          next if($config_target->{ABORTED});
          my $droot = vinfo($config_target->{url});
          my $target_type = $config_target->{target_type} || die;

          if($target_type eq "send-receive")
          {
            if(config_key($config_target, "receive_log")) {
              WARN "Ignoring deprecated option \"receive_log\" for target: $droot->{URL}"
            }

            # resume missing backups (resume_missing)
            if(config_key($config_target, "resume_missing"))
            {
              INFO "Checking for missing backups of subvolume \"$svol->{URL}\" in: $droot->{URL}/";
              my @schedule;
              my $found_missing = 0;

              # sort children of svol ascending by generation
              foreach my $child (get_snapshot_children($sroot, $svol))
              {
                if(scalar get_receive_targets($droot, $child)) {
                  DEBUG "Found matching receive target, skipping: $child->{URL}";
                }
                else {
                  DEBUG "No matching receive targets found, adding resume candidate: $child->{URL}";

                  # check if the target would be preserved
                  my ($date, $date_ext) = get_date_tag($child->{SUBVOL_PATH});
                  next unless($date && ($child->{SUBVOL_PATH} =~ /^\Q$snapdir\/$snapshot_basename.\E/));
                  push(@schedule, { value => $child, date => $date, date_ext => $date_ext }),
                }
              }

              if(scalar @schedule)
              {
                DEBUG "Checking schedule for resume candidates";
                # add all present backups to schedule, with no value
                # these are needed for correct results of schedule()
                foreach my $vol (keys %{$droot->{SUBVOL_INFO}}) {
                  my ($date, $date_ext) = get_date_tag($vol);
                  my $snapshot_basename = $config_subvol->{rel_path};  # TODO: add configuration option for this, store into svol
                  next unless($date && ($vol =~ s/^\Q$snapshot_basename.\E//));  # use only the date suffix for sorting
                  push(@schedule, { value => undef, date => $date, date_ext => $date_ext });
                }

                my ($preserve, undef) = schedule(
                  schedule             => \@schedule,
                  today                => \@today,
                  preserve_day_of_week => config_key($config_target, "preserve_day_of_week"),
                  preserve_daily       => config_key($config_target, "target_preserve_daily"),
                  preserve_weekly      => config_key($config_target, "target_preserve_weekly"),
                  preserve_monthly     => config_key($config_target, "target_preserve_monthly"),
                 );
                my @resume = grep defined, @$preserve;   # remove entries with no value from list (target subvolumes)

                foreach my $child (sort { $a->{node}->{gen} <=> $b->{node}->{gen} } @resume) {
                  INFO "Resuming subvolume backup (send-receive) for: $child->{URL}";
                  $found_missing++;
                  my ($latest_common_src, $latest_common_target) = get_latest_common($sroot, $svol, $droot, $child->{node}->{gen});
                  if(macro_send_receive($config_target,  # TODO: !!! adapt this function
                                        snapshot  => $child,
                                        target    => $droot,
                                        parent    => $latest_common_src,  # this is <undef> if no common found
                                        resume    => 1,     # propagated to $config_target->{subvol_received}
                                       ))
                  {
                    # tag the source snapshot, so that get_latest_common() above can make use of the newly received subvolume
                    $child->{RECEIVE_TARGET_PRESENT} = $droot->{URL};
                  }
                  else {
                    # note: ABORTED flag is already set by macro_send_receive()
                    ERROR("Error while resuming backups, aborting");
                    last;
                  }
                }
              }

              if($found_missing) {
                INFO "Resumed $found_missing backups";
              } else {
                INFO "No missing backups found";
              }
            }

            # skip creation if resume_missing failed
            next if($config_target->{ABORTED});
            die unless($config_subvol->{SNAPSHOT});

            # finally receive the previously created snapshot
            INFO "Creating subvolume backup (send-receive) for: $svol->{URL}";
            my ($latest_common_src, $latest_common_target) = get_latest_common($sroot, $svol, $droot);
            macro_send_receive($config_target,
                               snapshot => $config_subvol->{SNAPSHOT},
                               target   => $droot,
                               parent   => $latest_common_src,  # this is <undef> if no common found
                              );
          }
          else {
            ERROR "Unknown target type \"$target_type\", skipping: $svol->{URL}";
            $config_target->{ABORTED} = "Unknown target type \"$target_type\"";
          }
        }
      }
    }


    #
    # remove backups following a preserve daily/weekly/monthly scheme
    #
    if($preserve_backups) {
      INFO "Preserving all backups (option \"-p\" present)";
    }
    else
    {
      foreach my $config_vol (@{$config->{VOLUME}})
      {
        next if($config_vol->{ABORTED});
        my $sroot = vinfo($config_vol->{url});
        foreach my $config_subvol (@{$config_vol->{SUBVOLUME}})
        {
          next if($config_subvol->{ABORTED});
          my $svol = vinfo($config_subvol->{url});
          my $snapdir = config_key($config_subvol, "snapshot_dir") || "";
          my $snapshot_basename = $config_subvol->{rel_path};  # !!! TODO: add configuration option for this, store into svol
          my $target_aborted = 0;
          foreach my $config_target (@{$config_subvol->{TARGET}})
          {
            if($config_target->{ABORTED}) {
              $target_aborted = 1;
              next;
            }
            my $droot = vinfo($config_target->{url});

            #
            # delete backups
            #
            INFO "Cleaning backups of subvolume \"$svol->{URL}\": $droot->{URL}/$snapshot_basename.*";
            my @schedule;
            foreach my $vol (keys %{$droot->{SUBVOL_INFO}}) {
              my ($date, $date_ext) = get_date_tag($vol);
              next unless($date && ($vol =~ /^\Q$svol.\E/));
              push(@schedule, { value => "$droot->{URL}/$vol", name => $vol, date => $date, date_ext => $date_ext });
            }
            my (undef, $delete) = schedule(
              schedule             => \@schedule,
              today                => \@today,
              preserve_day_of_week => config_key($config_target, "preserve_day_of_week"),
              preserve_daily       => config_key($config_target, "target_preserve_daily"),
              preserve_weekly      => config_key($config_target, "target_preserve_weekly"),
              preserve_monthly     => config_key($config_target, "target_preserve_monthly"),
              log_verbose          => 1,
             );
            my $ret = btrfs_subvolume_delete($config_target, @$delete);
            if(defined($ret)) {
              INFO "Deleted $ret subvolumes in: $droot->{URL}/$snapshot_basename.*";
              $config_target->{SUBVOL_DELETED} = $delete;
            }
            else {
              $config_target->{ABORTED} = "btrfs subvolume delete command failed";
              $target_aborted = 1;
            }
          }

          #
          # delete snapshots
          #
          if($target_aborted) {
            WARN "Skipping cleanup of snapshots for subvolume \"$svol->{URL}\", as at least one target aborted earlier";
            next;
          }
          INFO "Cleaning snapshots: $sroot->{URL}/$snapdir/$snapshot_basename.*";
          my @schedule;
          foreach my $vol (keys %{$sroot->{SUBVOL_INFO}}) {
            my ($date, $date_ext) = get_date_tag($vol);
            next unless($date && ($vol =~ /^\Q$snapdir\/$snapshot_basename.\E/));
            push(@schedule, { value => "$sroot->{URL}/$vol", name => $vol, date => $date, date_ext => $date_ext });
          }
          my (undef, $delete) = schedule(
            schedule             => \@schedule,
            today                => \@today,
            preserve_day_of_week => config_key($config_subvol, "preserve_day_of_week"),
            preserve_daily       => config_key($config_subvol, "snapshot_preserve_daily"),
            preserve_weekly      => config_key($config_subvol, "snapshot_preserve_weekly"),
            preserve_monthly     => config_key($config_subvol, "snapshot_preserve_monthly"),
            log_verbose          => 1,
           );
          my $ret = btrfs_subvolume_delete($config_subvol, @$delete);
          if(defined($ret)) {
            INFO "Deleted $ret subvolumes in: $sroot->{URL}/$snapdir/$snapshot_basename.*";
            $config_subvol->{SUBVOL_DELETED} = $delete;
          }
          else {
            $config_subvol->{ABORTED} = "btrfs subvolume delete command failed";
          }
        }
      }
    }

    my $time_elapsed = time - $start_time;
    INFO "Completed within: ${time_elapsed}s  (" . localtime(time) . ")";

    #
    # print summary
    #
    unless($quiet)
    {
      my $err_count = 0;
      print "--------------------------------------------------------------------------------\n";
      print "Backup Summary ($version_info)\n\n";
      print "    Date:   " . localtime($start_time) . "\n";
      print "    Config: $config->{SRC_FILE}\n";
      print "\nLegend:\n";
      print "    +++  created subvolume (source snapshot)\n";
      print "    ---  deleted subvolume\n";
      print "    ***  received subvolume (non-incremental)\n";
      print "    >>>  received subvolume (incremental)\n";
      # print "    %>>  received subvolume (incremental, resume_missing)\n";
      print "--------------------------------------------------------------------------------";
      foreach my $config_vol (@{$config->{VOLUME}})
      {
        if($config_vol->{ABORTED}) {
          print "!!! $config_vol->{url}: ABORTED: $config_vol->{ABORTED}\n";
          $err_count++ unless($config_vol->{ABORTED_NOERR});
        }
        foreach my $config_subvol (@{$config_vol->{SUBVOLUME}})
        {
          my $svol = vinfo($config_subvol->{url});
          print "\n$svol->{PRINT}\n";
          if($config_subvol->{ABORTED}) {
            print "!!! Subvolume \"$config_subvol->{rel_path}\" aborted: $config_subvol->{ABORTED}\n";
            $err_count++ unless($config_subvol->{ABORTED_NOERR});
          }
          print "+++ $config_subvol->{SNAPSHOT}->{PRINT}\n" if($config_subvol->{SNAPSHOT});
          if($config_subvol->{SUBVOL_DELETED}) {
            print "--- $_\n" foreach(sort { $b cmp $a} @{$config_subvol->{SUBVOL_DELETED}});
          }
          foreach my $config_target (@{$config_subvol->{TARGET}})
          {
            foreach(@{$config_target->{subvol_received} // []}) {
              my $create_mode = "***";
              $create_mode = ">>>" if($_->{parent});
              # substr($create_mode, 0, 1, '%') if($_->{resume});
              $create_mode = "!!!" if($_->{ERROR});
              print "$create_mode $_->{received_name}\n";
            }

            if($config_target->{SUBVOL_DELETED}) {
              print "--- $_\n" foreach(sort { $b cmp $a} @{$config_target->{SUBVOL_DELETED}});
            }

            if($config_target->{ABORTED}) {
              print "!!! Target \"$config_target->{url}\" aborted: $config_target->{ABORTED}\n";
              $err_count++ unless($config_target->{ABORTED_NOERR});
            }
          }
        }
      }
      if($err_count) {
        print "\nNOTE: Some errors occurred, which may result in missing backups!\n";
        print "Please check warning and error messages above.\n";
      }
      if($preserve_backups) {
        print "\nNOTE: Preserved all backups (option -p present)\n";
      }
      if($dryrun) {
        print "\nNOTE: Dryrun was active, none of the operations above were actually executed!\n";
      }
    }
  }
}


1;
